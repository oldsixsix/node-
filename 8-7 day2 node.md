# node第二天学习

## 1.1 art-template

   {0:08/07/19 17:03:19 +08:00} 

## 1.2 art-template在node中的使用

 -    1.npm安装art-template
-     2.在需要使用的文件中加载art-template 用require当做核心模块加载就可以了（参数就是你npm安装的包名）
-     3.查看art-template模板引擎的API学习如何使用
-     4.模板引擎中的解析功能只认识{{}}其余的内容什么都不管，只解决数据的渲染看到{{}}就进行数据渲染

##1.3 模板引擎读取的注意事项

    1.默认读取到的data是2进制数据而模板引擎中的data是需要接收字符串 所以我们在这里需要把data二进制数据转换成字符串才可以给模板引擎使用
    2.这里使用tostring方法把data数据转换成字符串

## ##1.4 在node中用模板引擎--服务端渲染

​    1.其实质就是字符串解析和替换

## ##1.5 复习上午  

​      -   1.代码风格
​    - 1.JavaScript standar style
​    - 2.爱彼迎风格
​    - 2.无分号写法会出现的问题（三个地方前面要加分号）
​    - （）
​    -  []
​    -  ``
​    - 3.初步实现apache功能

## ##1.6. 服务器渲染

​    后端将html拼接好返回给前端完整的html文件，浏览器拿到这个html文件之后直接解析展示即可。浏览器只负责html文件的解析和展示没有其他功能
​    页面+数据都是服务端渲染好的，提供的是完整的html文件
##1.7. 客户端渲染
​    

- 前端页面复杂性的提高，以及前后端分离的开发模式的兴起。
- 前端就不仅仅是普通页面的展示，而可能添加更多功能性组件更加复杂。
- 另外ajax的方法，是的后端不提供完整的html页面而是提供一些API使得前端可以获取json数据，而前端拿到json数据之后再在前端进行html页面的拼接，然后展示到浏览器上，这样前端专注于UI的开发，后端专注于逻辑的开发
- 服务端只提供数据
- 前端专注于页面

  ## 1.8. 两者的本质区别 
1. 就是谁来完成html文件的拼接
1. 如果是在服务器端完成的，然后返回给客户端就是服务器渲染
1. 如果前端做了更多的html文件的拼接工作则就是客户端渲染
2. 客户端渲染不利于搜索引擎优化
3. 服务端渲染是可以被爬虫抓取到的，客户端渲染是很难被爬虫抓取到的
4. 
  
## 1.9 服务端处理网站的静态资源
- 把所有的文件路径都可以看成url路径
- 我们要做的就是网站中访问的地址与静态资源的文件地址一致，通过.+url拼接出来
- 通过`else if(url.indexOf('/public/')===0)`判断路径是否是以public开头，当以public开头的时候开放资源访问。
- 这种方式可以自己设定开放的资源目录，客户端只能访问服务器设定的开放目录
- 为了方便统一的管理这些静态资源，我们约定把所有的静态资源都放到public中
- 那些资源能被用户访问到，那些资源不能被用户访问，我现在可以通过代码来非常灵活的控制了
- 案例中把整个public中的资源都公开了
- 你能访问什么，不能访问什么，全部由自己控制

## 1.10 url美化--去后缀名.html .css等等
- 要改两个地方
- （1）a便签的href，就相当于请求路径
- （2）第二个地方if判断url时改成post就行了就是读取文件路径readfile
- http://127.0.0.1:3000/post，这样就访问


## 2.1 url中的parse方法
parse方法1
========
![](https://i.imgur.com/pJ1EoVS.png)
parse方法2
========
![parse方法2](https://i.imgur.com/cyMNVZN.png)

##2.2 案例知识点--写App.js代码
1. index页面
2. 开放public目录中的静态资源--当请求/Public/xxx的时候，读取响应public目录中的具体资源
3. /post页面 这里有一个url优化的知识点，取消后缀
4. /comment页面
    1. 接收表单提交的数据
    2. 存储表单提交的数据
    3. 让表单重定向到/
        1. 状态码
        2. location

